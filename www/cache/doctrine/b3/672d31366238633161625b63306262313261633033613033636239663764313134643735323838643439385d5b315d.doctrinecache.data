1498334736
a:2:{s:7:"content";s:5339:"<p>Enfin! Des changements importants pour JAVA! Tant de points attendus. Voici quelques unes des innovations de cette version.</p>
<p>===</p>
<h3>Informations</h3>
<table>
<thead>
<tr>
<th>Date de sortie</th>
</tr>
</thead>
<tbody>
<tr>
<td>2014</td>
</tr>
</tbody>
</table>
<h3>I. Les nouveautés</h3>
<h6><strong>Les Lambdas</strong></h6>
<p>Les lambdas expressions permettent de simplifier l'écriture du code. </p>
<div class="notices red">
<p>Comment la JVM fait-elle pour s’y retrouver et savoir quelle méthode instancier ? La réponse tient en deux mots : interface fonctionnelle. Une interface fonctionnelle est une interface qui ne définit qu’une seule méthode.</p>
</div>
<p>Par exemple :</p>
<pre><code class="language-java">button.addEventListener(new ActionListener() {
    public void actionPerformed(ActionEvent e) {
      System.out.println("Click");
    }
});</code></pre>
<p>devient :   </p>
<pre><code class="language-java">button.addEventListener(e -&gt; System.out.println("Click"));  </code></pre>
<div class="notices red">
<p>Par contre si on voulait que notre méthode soit un peu plus complexe, la syntaxe de la lambda s’alourdirait notamment avec l’usage du mot-clef <em>return</em> qui est facultatif dans le cas où la lambda ne contient qu’une seule opération. Par exemple on pourrait avoir :</p>
</div>
<pre><code class="language-java">(a, b) -&gt; {
   double res = a + b;
   System.out.println(res);
   return res;
}</code></pre>
<hr />
<p>Les références de méthodes sont aussi un truc sympa de Java 8 introduit par les lambdas.
Mettons qu’on ait un tableau de String dont la déclaration est comme suit :</p>
<pre><code class="language-java">String[] myArray = {"one", "two", "three", "four"};</code></pre>
<p>Il est parfaitement possible de le trier avec la notation suivante :</p>
<pre><code class="language-java">Arrays.sort(myArray, String::compareToIgnoreCase);</code></pre>
<p>​   </p>
<hr />
<p>​   </p>
<h6><strong>Les Streams</strong></h6>
<p>Les streams sont un ajout au framework Collections en Java 8. Ils permettent en particulier d’utiliser les systèmes de map/reduce sur ces collections. </p>
<p>Un map/reduce se divise en deux étapes :</p>
<ul>
<li>Tout d’abord la phase de map, qui consiste à appliquer une ou plusieurs opérations à chaque élément de la collection.</li>
<li>Ensuite la phase de reduce, qui est utilisée pour récupérer le résultat. Ce dernier peut être une collection, un objet, ou n’importe quoi d’autre.</li>
</ul>
<p>L’avènement de ce type de programmation a eu lieu avec les processeurs multi-cores. Un exemple simple consiste par exemple à multiplier tous les éléments d’une liste par 5. En fonctionnement itératif simple, on bouclerait sur chaque élément de la liste, puis on multiplierait chacun des éléments par 5. En map/reduce, on peut par contre opérer de la manière suivante :</p>
<ul>
<li>Diviser la liste en autant de part qu’il y a de cores sur la machine</li>
<li>Attribuer chaque sous-liste à un cores, qui multiplie par 5 chacun des éléments de sa sous-liste</li>
<li>Enfin rassembler les listes calculées</li>
</ul>
<p>Le gain de performances vient du fait que le temps de calcul est cette fois divisé par le nombre de cores sur la machine. Implémenter une telle division en itératif serait très complexe.
​   </p>
<hr />
<p>​   </p>
<h6><strong>Les Stamped Lock</strong></h6>
<p>Alternative aux ReadWriteLock pour les traitements multi-threadés, ce nouveau verrou est beaucoup plus rapide mais cependant plus compliqué à utiliser.</p>
<pre><code class="language-java">long stamp = lock.tryOptimisticRead(); // non blocking path - super fast
work(); // we're hoping no writing will go on in the meanwhile
if (lock.validate(stamp)){
       //success! no contention with a writer thread 
}
else {
       //another thread must have acquired a write lock in the meanwhile, changing the stamp. 
       //bummer - let's downgrade to a heavier read lock

        stamp = lock.readLock(); //this is a traditional blocking read lock 
        try {
                 //no writing happening now
                 work();

        }
        finally {
            lock.unlock(stamp); // release using the correlating stamp
        }
}</code></pre>
<hr />
<p>Arrays offre maintenant la possibilité d'effectuer des tris en parallèles pour accélerer ces derniers.</p>
<pre><code class="language-java">Arrays.parallelSort(myArray);</code></pre>
<hr />
<p>Enfin! JodaTime fait maintenant parti du standard JAVA. Pas la peine d'expliquer l'intérêt ;)</p>
<hr />
<p>​   </p>
<h6><strong>Les Références Optionnelles</strong></h6>
<p>Il est possible que dans certains cas, une référence <em>null</em> soit acceptable. Pour éviter les NullPointerException, un nouveau modéle a été ajouté :</p>
<pre><code class="language-java">Optional&lt;T&gt;</code></pre>
<p>Ce dernier ajoute plusieurs fonctions comme <em>isPresent</em> qui vérifie que la valeur est non null</p>
<h3>II. Liens utiles</h3>
<ul>
<li><a href="http://jobprod.com/les-nouveautes-de-java-8/">jobprod.com</a></li>
<li>
<p><a href="https://www.infoq.com/fr/articles/Java-8-Quiet-Features">infog.com</a></p>
</li>
<li><a href="http://soat.developpez.com/tutoriels/java/projet-lambda-java8/">Soat.developpez.com</a></li>
</ul>";s:12:"content_meta";N;}