1487172503
a:2:{s:7:"content";s:3476:"<p>Enfin! Des changements importants pour JAVA! Tant de points attendus. Voici quelques unes des innovations de cette version.</p>
<p>===</p>
<h3>Informations</h3>
<table>
<thead>
<tr>
<th>Date de sortie</th>
</tr>
</thead>
<tbody>
<tr>
<td>2014</td>
</tr>
</tbody>
</table>
<h3>I. Les nouveautés</h3>
<p>Les lambdas expressions permettent de simplifier l'écriture du code. </p>
<div class="notices red">
<p>Comment la JVM fait-elle pour s’y retrouver et savoir quelle méthode instancier ? La réponse tient en deux mots : interface fonctionnelle. Une interface fonctionnelle est une interface qui ne définit qu’une seule méthode.</p>
</div>
<p>Par exemple :</p>
<pre><code>button.addEventListener(new ActionListener() {

   public void actionPerformed(ActionEvent e) {
      System.out.println("Click");
   }

});</code></pre>
<p>devient :   </p>
<pre><code>button.addEventListener(e -&gt; System.out.println("Click"));  </code></pre>
<div class="notices red">
<p>Par contre si on voulait que notre méthode soit un peu plus complexe, la syntaxe de la lambda s’alourdirait notamment avec l’usage du mot-clef <em>return</em> qui est facultatif dans le cas où la lambda ne contient qu’une seule opération. Par exemple on pourrait avoir :</p>
</div>
<pre><code>(a, b) -&gt; {
   double res = a + b;
   System.out.println(res);
   return res;
}</code></pre>
<p>Les références de méthodes sont aussi un truc sympa de Java 8 introduit par les lambdas.
Mettons qu’on ait un tableau de String dont la déclaration est comme suit :</p>
<pre><code>String[] myArray = {"one", "two", "three", "four"};</code></pre>
<p>Il est parfaitement possible de le trier avec la notation suivante :</p>
<pre><code>Arrays.sort(myArray, String::compareToIgnoreCase);</code></pre>
<h6>Les streams</h6>
<p>Les streams sont un ajout au framework Collections en Java 8. Ils permettent en particulier d’utiliser les systèmes de map/reduce sur ces collections. </p>
<p>Un map/reduce se divise en deux étapes :</p>
<ul>
<li>Tout d’abord la phase de map, qui consiste à appliquer une ou plusieurs opérations à chaque élément de la collection.</li>
<li>Ensuite la phase de reduce, qui est utilisée pour récupérer le résultat. Ce dernier peut être une collection, un objet, ou n’importe quoi d’autre.</li>
</ul>
<p>L’avènement de ce type de programmation a eu lieu avec les processeurs multi-cores. Un exemple simple consiste par exemple à multiplier tous les éléments d’une liste par 5. En fonctionnement itératif simple, on bouclerait sur chaque élément de la liste, puis on multiplierait chacun des éléments par 5. En map/reduce, on peut par contre opérer de la manière suivante :</p>
<ul>
<li>Diviser la liste en autant de part qu’il y a de cores sur la machine</li>
<li>Attribuer chaque sous-liste à un cores, qui multiplie par 5 chacun des éléments de sa sous-liste</li>
<li>Enfin rassembler les listes calculées</li>
</ul>
<p>Le gain de performances vient du fait que le temps de calcul est cette fois divisé par le nombre de cores sur la machine. Implémenter une telle division en itératif serait très complexe.</p>
<h3>II. Liens utiles</h3>
<ul>
<li><a href="http://jobprod.com/les-nouveautes-de-java-8/">jobprod.com</a></li>
<li>
<p><a href="https://www.infoq.com/fr/articles/Java-8-Quiet-Features">infog.com</a></p>
</li>
<li><a href="http://soat.developpez.com/tutoriels/java/projet-lambda-java8/">Soat.developpez.com</a></li>
</ul>";s:12:"content_meta";N;}